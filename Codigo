#define F_CPU 16000000UL // Clock do Arduino Uno
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

// PINOS DO PROJETO
// PD6 (Digital 6) -> Saída PWM para o motor.
// PD2 (Digital 2) -> Entrada de Interrupção (INT0) para o sensor de rotação.

#define PPR 1 // Pulsos por Rotação (Ajuste conforme o seu disco)

// Variáveis Globais Voláteis (Para uso nas Interrupções)
volatile uint16_t contagem_pulsos = 0;   
volatile uint8_t sinal_rpm = 0;          
volatile uint16_t pulsos_capturados = 0; 
volatile uint8_t duty_desejado = 0;     // Ciclo de trabalho desejado (0-100%)

// ----------------------------------------------------
// 1. Funções de Comunicação Serial (UART)
// ----------------------------------------------------

void UART_init(void) {
   // Define a taxa de transmissão (Baud Rate 9600 para 16 MHz)
    uint16_t ubrr = 103;                       
    UBRR0H = ubrr >> 8;
    UBRR0L = ubrr;
    UCSR0B = (1 << RXEN0) | (1 << TXEN0);    // Habilita o Receptor (RX) e o Transmissor (TX)   
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00);   // Configura 8 bits de dados e sem paridade  
}

void UART_send_char(char c) {
    while (!(UCSR0A & (1 << UDRE0)));
    UDR0 = c;
}

void UART_send_string(const char *s) {
    while (*s) UART_send_char(*s++);
}

// Inicialização e Controle do PWM (Timer 0 no PD6)

void PWM_init(void) {
    DDRD |= (1 << PD6);                      
    TCCR0A = (1 << WGM00) | (1 << WGM01) | (1 << COM0A1); 
    TCCR0B = (1 << CS01) | (1 << CS00);      
    OCR0A = 0;                               
}

void PWM_set_duty(uint8_t duty) {
    OCR0A = (uint8_t)((uint32_t)duty * 255UL / 100UL);
}

//Inicialização do Sensor e Interrupção (INT0 no PD2)

void SENSOR_init(void) {
    DDRD &= ~(1 << PD2);                     
    PORTD |= (1 << PD2);                     
    EICRA |= (1 << ISC01);                   
    EICRA &= ~(1 << ISC00);
    EIMSK |= (1 << INT0);                    
}

//Inicia o timer 1 segundo

void TIMER1_init(void) {
    TCCR1B = (1 << WGM12) | (1 << CS12);     
    OCR1A = 62500 - 1;                       
    TIMSK1 |= (1 << OCIE1A);                 
}

//Interrupção (ISR)

ISR(INT0_vect) {
    contagem_pulsos++;
}

ISR(TIMER1_COMPA_vect) {
    pulsos_capturados = contagem_pulsos;
    contagem_pulsos = 0; 
    sinal_rpm = 1;       
}

int main(void) {
    UART_init();
    PWM_init();
    TIMER1_init();
    SENSOR_init();
    
    sei();

    // Variáveis locais para leitura
    int duty_leitura_temp = 0; 
    char linha[32];
    char numero[5]; 
    uint8_t indice_num = 0;

    UART_send_string("Sistema de Controle de Motor\r\n");
    UART_send_string("Comando: Digite um valor percentual (0 a 100) e ENTER, ou 'S' para parar.\r\n");

    while (1) {
        if (UCSR0A & (1 << RXC0)) {
            char c = UDR0;

            // Parar motor
            if (c == 'S' || c == 's') {
                duty_desejado = 0;
                PWM_set_duty(duty_desejado);
                UART_send_string("Comando de parada! Motor desligado (0%).\r\n");
                
                indice_num = 0; 
                memset(numero, 0, sizeof(numero));
                
            }
            else if ((c == '\n' || c == '\r') && indice_num > 0) {
                numero[indice_num] = '\0';
                duty_leitura_temp = atoi(numero); 
              
                // Verifica o valor
                if (duty_leitura_temp > 100 || duty_leitura_temp < 0) {
                    
                    //Mantem a velocidade anterior
                    // Informa o erro com o valor lido:
                    snprintf(linha, sizeof(linha), "ERRO: Numero invalido (%d). Use valores entre 0 e 100.\r\n", duty_leitura_temp);
                    UART_send_string(linha);
                    
                    //Informa a velocidade mantida (CORREÇÃO DO ERRO DE COMPILAÇÃO)
                    snprintf(linha, sizeof(linha), "Velocidade anterior mantida (%u%%).\r\n", duty_desejado);
                    UART_send_string(linha);
                    
                } else {
                    // Comando Válido (0% a 100%)
                    duty_desejado = (uint8_t)duty_leitura_temp;
                    PWM_set_duty(duty_desejado); // Aplica o novo PWM
                    snprintf(linha, sizeof(linha), "PWM ajustado para %u%%\r\n", duty_desejado);
                    UART_send_string(linha);
                }
                
                indice_num = 0;
                memset(numero, 0, sizeof(numero));
            }
            // Acúmulo de dígitos
            else if (c >= '0' && c <= '9' && indice_num < sizeof(numero) - 1) {
                numero[indice_num++] = c;
            }
            // Comando inválido
            else if ((c != '\n' && c != '\r') && (indice_num == 0)) {
                UART_send_string("ERRO: Comando invalido. Digite apenas o numero (0-100) ou 'S'.\r\n");
                indice_num = 0;
                memset(numero, 0, sizeof(numero));
            }
        }
        // CÁLCULO E EXIBIÇÃO DO RPM
        if (sinal_rpm) {
            sinal_rpm = 0;
            
            uint16_t rpm_atual = pulsos_capturados * (60 / PPR);

            snprintf(linha, sizeof(linha), "--> RPM Atual: %u\r\n", rpm_atual);
            UART_send_string(linha);
            
            snprintf(linha, sizeof(linha), "--> PWM Atual: %u%%\r\n", duty_desejado);
            UART_send_string(linha);
            UART_send_string("-------------------------------------\r\n");
        }
        .
        _delay_ms(10); 
    }
}

